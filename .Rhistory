Stable = new_data(new_data, 120) |>
mutate(ENSO = 0, aggregate_emissions=user_emissions)
)
future_scenarios$Stable
new_data
us_change
future_scenarios <- scenarios(
Increase = new_data(us_change, 4) |>
mutate(Income=1, Savings=0.5, Unemployment=0),
Decrease = new_data(us_change, 4) |>
mutate(Income=-1, Savings=-0.5, Unemployment=0),
names_to = "Scenario")
future_scenarios$Increase
fc <- forecast(fit_consBest, new_data = future_scenarios)
fit_consBest <- us_change |>
model(
lm = TSLM(Consumption ~ Income + Savings + Unemployment)
)
fc <- forecast(fit_consBest, new_data = future_scenarios)
us_change |>
autoplot(Consumption) +
autolayer(fc) +
labs(title = "US consumption", y = "% change")
us_change |>
autoplot(Consumption |> filter(year(Quarter) > 2000)) +
autolayer(fc) +
labs(title = "US consumption", y = "% change")
us_change |>
autoplot(Consumption |> filter(year(Quarter)) > 2000) +
autolayer(fc) +
labs(title = "US consumption", y = "% change")
us_change
us_change |>
filter(year(Quarter) > 2000) |>
autoplot(Consumption) +
autolayer(fc) +
labs(title = "US consumption", y = "% change")
tail(new_data$aggregate_emissions)
new_data |>
filter(year(Date) == 2024) |>
sum(Total_CO2)
new_data |>
filter(year(Date) == 2024) |>
sum(Total_CO2)
sum(new_data |> filter(year(Date) == 2024) |> select(Total_CO2))
co2 <- new_data |> filter(year(Date) == 2024) |> select(Total_CO2)
co2
sum(co2$Total_CO2)
future_scenario <- new_data |>
filter(FALSE) |> # Empty copy of structure
bind_rows(
tibble(
Date = seq(as.Date("2025-01-01"), by = "month", length.out = 240),
# USER INPUT GOES HERE:
aggregate_emissions = 5000,  # Value from user slider
# Set ENSO to neutral (0) to see pure trend
ENSO = 0
)
)
future_scenario
future_scenario$aggregate_emissions
new_data |>
filter(year(Date) == 2024) |>
tail(
)
new_data |>
filter(year(Date) == 2024) |>
tail() |> select(aggregate_emissions)
?seq
new_data
tail(new_data)
tail(new_data |> filter(year(Date) == 2024))
mean(new_data |> filter(year(Date) == 2024) |> select(Total_CO2))
mean(co2)
mean(co2$Total_CO2)
x <- 10
x <- 1
monthly_2024_baseline <- 3970830
user_emissions <- x / 100 + 1
add_to_2024 <- monthly_2024_baseline * user_emissions
future_scenarios <- scenarios(
Stable = new_data(new_data, 1) |>
mutate(ENSO = 0, Total_CO2=add_to_2024)
)
bind_rows(new_data, future_scenarios$Stable)
tail(new_data)
fun_data <- bind_rows(new_data, future_scenarios$Stable)
tail(FUN_DATA)
tail(fun_data)
new_data <- bind_rows(new_data, future_scenarios$Stable)
future_scenarios <- scenarios(
Stable = new_data(new_data, 1) |>
mutate(ENSO = 0, Total_CO2=add_to_2024)
)
new_data <- bind_rows(new_data, future_scenarios$Stable)
tail(new_data)
scenario_data <- new_data |>
slice(n = n() - 2) |>
select(Date, actual_temp, co2_ppm, Total_CO2, aggregate_emissions, ENSO)
scenario_data <- new_data |>
slice(1:n() - 2) |>
select(Date, actual_temp, co2_ppm, Total_CO2, aggregate_emissions, ENSO)
scenario_data <- new_data |>
slice(1:(n() - 2)) |>
select(Date, actual_temp, co2_ppm, Total_CO2, aggregate_emissions, ENSO)
tail(scenario_data)
# --- 1. User Inputs (These would come from your App UI) ---
input_years <- 5          # User wants 5 years forecast
input_growth_pct <- 1.0   # User wants 1% monthly growth in emissions
n_months <- input_years * 12
# --- 2. Get Baseline Values (The specific numbers from the very last historical row) ---
last_historical_row <- new_data |> tail(1)
start_date <- last_historical_row$Date
base_co2_flow <- last_historical_row$Total_CO2           # Current monthly emissions (Gg)
base_emissions_stock <- last_historical_row$aggregate_emissions # Current total pile (Gt)
# --- 3. Create the Future Dataframe ---
future_scenario <- tibble(
Date = seq(start_date %m+% months(1), by = "month", length.out = n_months),
ENSO = 0  # Scenario assumption: Neutral ENSO
) |>
mutate(
# A. Calculate Growth of Monthly Emissions (Compounding)
# Formula: Last_Value * (1 + rate) ^ month_number
growth_factor = 1 + (input_growth_pct / 100),
Total_CO2 = base_co2_flow * (growth_factor ^ row_number()),
# B. Calculate Aggregate Emissions (Accumulation)
# 1 Gigagram (Gg) = 0.000001 Gigatons (Gt)
# We take the cumulative sum of the NEW emissions, convert to Gt, and add to baseline
cumulative_additions_Gt = cumsum(Total_CO2) * 1e-6,
aggregate_emissions = base_emissions_stock + cumulative_additions_Gt
)
# --- 3. Create the Future Dataframe ---
future_scenario <- tibble(
# FIX: For yearmonth objects, just add the sequence 1, 2, 3... to get future months
Date = start_date + (1:n_months),
ENSO = 0
) |>
mutate(
# Calculate Growth
growth_factor = 1 + (input_growth_pct / 100),
# Compound growth: base * (1.01)^1, base * (1.01)^2, etc.
Total_CO2 = base_co2_flow * (growth_factor ^ row_number()),
# Calculate Accumulation
cumulative_additions_Gt = cumsum(Total_CO2) * 1e-6,
aggregate_emissions = base_emissions_stock + cumulative_additions_Gt
)
# --- 4. Handle the Lags Correctly ---
# We must stick history and future together briefly so lag(ENSO) works
# for the first few months of 2025 (looking back at late 2024)
full_data_linked <- bind_rows(new_data, future_scenario)
# --- 5. Extract just the clean Future Scenario ---
# This is what you pass to your forecast() function
scenario_stable <- full_data_linked |>
filter(Date > start_date) |>
select(Date, Total_CO2, aggregate_emissions, ENSO)
# View the first few rows to verify
head(scenario_stable)
last_historical_row
# --- 2. Get Baseline Values (The specific numbers from the very last historical row) ---
last_historical_row <- scenario_data |> tail(1)
start_date <- last_historical_row$Date
base_co2_flow <- last_historical_row$Total_CO2           # Current monthly emissions (Gg)
base_emissions_stock <- last_historical_row$aggregate_emissions # Current total pile (Gt)
# --- 3. Create the Future Dataframe ---
future_scenario <- tibble(
# FIX: For yearmonth objects, just add the sequence 1, 2, 3... to get future months
Date = start_date + (1:n_months),
ENSO = 0
) |>
mutate(
# Calculate Growth
growth_factor = 1 + (input_growth_pct / 100),
# Compound growth: base * (1.01)^1, base * (1.01)^2, etc.
Total_CO2 = base_co2_flow * (growth_factor ^ row_number()),
# Calculate Accumulation
cumulative_additions_Gt = cumsum(Total_CO2) * 1e-6,
aggregate_emissions = base_emissions_stock + cumulative_additions_Gt
)
# --- 4. Handle the Lags Correctly ---
# We must stick history and future together briefly so lag(ENSO) works
# for the first few months of 2025 (looking back at late 2024)
full_data_linked <- bind_rows(new_data, future_scenario)
# --- 4. Handle the Lags Correctly ---
# We must stick history and future together briefly so lag(ENSO) works
# for the first few months of 2025 (looking back at late 2024)
full_data_linked <- bind_rows(scenario_data, future_scenario)
# --- 5. Extract just the clean Future Scenario ---
# This is what you pass to your forecast() function
scenario_stable <- full_data_linked |>
filter(Date > start_date) |>
select(Date, Total_CO2, aggregate_emissions, ENSO)
# View the first few rows to verify
head(scenario_stable)
)
ppm_model <- new_data |>
filter((year(Date) > 1957)) |>
model(
ppm_arima = ARIMA(co2_ppm ~ 0 + aggregate_emissions + ENSO + PDQ(0, 1, 1) + pdq(1, 1, 1))
)
fc <- ppm_model |>
forecast(new_data = scenario_stable)
ppm_model
new_data |>
filter((year(Date) > 1957)) |>
tail()
ppm_model <- scenario_data |>
filter((year(Date) > 1957)) |>
model(
ppm_arima = ARIMA(co2_ppm ~ 0 + aggregate_emissions + ENSO + PDQ(0, 1, 1) + pdq(1, 1, 1))
)
fc <- ppm_model |>
forecast(new_data = scenario_stable)
fc
tail(fc)
temp_model <- scenario_data |>
true_data <- read_rds("data/lagged_nino_predictors.rds")
true_data <- read_rds("data/lagged_nino_predictors.rds")
tail(true_data)
scenario_final <- scenario_stable |>
mutate(co2_ppm = fc$.mean)
temp_forecast <- temp_model |>
forecast(new_data = scenario_final)
)
temp_model <- true_data |>
filter((year(Date) > 1957)) |>
model(
temp_arima = ARIMA(actual_temp ~ co2_ppm + ENSO + fourier(K = 3) + PDQ(0, 0, 0))
)
temp_forecast <- temp_model |>
forecast(new_data = scenario_final)
temp_forecast |>
autoplot(new_data) +
labs(title = "Forecasted Temperature",
subtitle = "Based on User-Defined CO2 Emissions Scenario")
temp_forecast |>
autoplot() +
autolayer(true_data |> filter(year(Date)) > 2020) +
labs(title = "Forecasted Temperature",
subtitle = "Based on User-Defined CO2 Emissions Scenario")
autolayer(true_data |> filter(year(Date) > 2020) +
subtitle = "Based on User-Defined CO2 Emissions Scenario")
subtitle = "Based on User-Defined CO2 Emissions Scenario")
temp_forecast |>
autoplot() +
autolayer(true_data |> filter(year(Date) > 2020)) +
labs(title = "Forecasted Temperature",
subtitle = "Based on User-Defined CO2 Emissions Scenario")
input_growth_pct <- 0   # User wants 1% monthly growth in emissions
# --- 2. Get Baseline Values (The specific numbers from the very last historical row) ---
last_historical_row <- true_data |> tail(1)
start_date <- last_historical_row$Date
base_co2_flow <- last_historical_row$Total_CO2           # Current monthly emissions (Gg)
base_emissions_stock <- last_historical_row$aggregate_emissions # Current total pile (Gt)
# --- 3. Create the Future Dataframe ---
future_scenario <- tibble(
# FIX: For yearmonth objects, just add the sequence 1, 2, 3... to get future months
Date = start_date + (1:n_months),
ENSO = 0
) |>
mutate(
# Calculate Growth
growth_factor = 1 + (input_growth_pct / 100),
# Compound growth: base * (1.01)^1, base * (1.01)^2, etc.
Total_CO2 = base_co2_flow * (growth_factor ^ row_number()),
# Calculate Accumulation
cumulative_additions_Gt = cumsum(Total_CO2) * 1e-6,
aggregate_emissions = base_emissions_stock + cumulative_additions_Gt
)
# --- 4. Handle the Lags Correctly ---
# We must stick history and future together briefly so lag(ENSO) works
# for the first few months of 2025 (looking back at late 2024)
full_data_linked <- bind_rows(true_data, future_scenario)
# --- 5. Extract just the clean Future Scenario ---
# This is what you pass to your forecast() function
scenario_stable <- full_data_linked |>
filter(Date > start_date) |>
select(Date, Total_CO2, aggregate_emissions, ENSO)
# View the first few rows to verify
head(scenario_stable)
stable_fc <- ppm_model |>
forecast(new_data = scenario_stable)
scenario_final <- scenario_stable |>
mutate(co2_ppm = fc$.mean)
stable_temp_forecast <- temp_model |>
forecast(new_data = scenario_final)
stable_temp_forecast |>
autoplot() +
autolayer(temp_forecast) +
labs(title = "Forecasted Temperature",
subtitle = "Based on User-Defined CO2 Emissions Scenario")
combined_forecasts <- bind_rows(
stable_temp_forecast |> mutate(Scenario = "Stable"),
temp_forecast |> mutate(Scenario = "User Defined")
)
stable_temp_forecast
# 1. Combine and Update Structure
combined_forecasts <- bind_rows(
stable_temp_forecast |> mutate(Scenario = "Stable"),
temp_forecast |> mutate(Scenario = "User Defined")
) |>
# This is the magic step that fixes the error:
as_fable(index = Date, key = c(Scenario, .model), distribution = actual_temp)
# 1. Convert to simple data frames first (removes the "fable" strictness)
f1 <- as_tibble(stable_temp_forecast) |> mutate(Scenario = "Stable")
f2 <- as_tibble(temp_forecast) |> mutate(Scenario = "User Defined")
# 2. Bind them together safely
combined_df <- bind_rows(f1, f2)
# 3. Convert back to a Fable object
# We must explicitly tell it which column holds the distribution (actual_temp)
combined_fable <- combined_df |>
as_fable(
index = Date,
key = c(Scenario, .model),
response = "actual_temp",      # The name of your response variable
distribution = actual_temp     # The column containing the distribution data
)
# 4. Now plot
combined_fable |>
autoplot(new_data) +
labs(title = "Temperature Forecast Scenarios",
y = "Temperature Anomaly",
color = "Scenario",
fill = "Scenario")
# 4. Now plot
combined_fable |>
autoplot(true_data) +
labs(title = "Temperature Forecast Scenarios",
y = "Temperature Anomaly",
color = "Scenario",
fill = "Scenario")
combined_fable
combined_df |>
ggplot(aes(x = Date, y = .mean, color = Scenario)) +
# Add the historical data as a black line
geom_line(data = new_data, aes(y = actual_temp, color = "History"), inherit.aes = FALSE) +
# Add the forecast lines
geom_line(size = 1) +
labs(title = "Temperature Forecast Scenarios",
y = "Temperature Anomaly") +
theme_minimal()
# 1. Convert both forecasts to plain data frames and label them
df_stable <- as_tibble(stable_temp_forecast) |> mutate(Scenario = "Stable")
df_user   <- as_tibble(temp_forecast)        |> mutate(Scenario = "User Defined")
# 2. Combine them
combined_df <- bind_rows(df_stable, df_user)
# 3. Plot Manually
ggplot() +
# LAYER 1: The Historical Data (Black line)
# We MUST specify x and y here explicitly
geom_line(data = new_data,
aes(x = Date, y = actual_temp, color = "Historical Data"),
size = 1) +
# LAYER 2: The Forecasts (Colored lines by Scenario)
geom_line(data = combined_df,
aes(x = Date, y = .mean, color = Scenario),
size = 1) +
# Optional: Add the prediction intervals (Ribbons)
# Note: .mean is the center, actual_temp is the distribution name
# usually fable outputs columns like 'lower' and 'upper' in hilo(),
# but for a simple line plot, we often skip ribbons in Apps to reduce clutter.
# Styling
scale_color_manual(values = c("Historical Data" = "black",
"Stable" = "blue",
"User Defined" = "red")) +
labs(title = "Temperature Forecast Scenarios",
subtitle = "Comparing Stable vs. User Emissions",
y = "Temperature Anomaly",
x = "Year") +
theme_minimal()
# 3. Plot Manually
ggplot() +
# LAYER 1: The Historical Data (Black line)
# We MUST specify x and y here explicitly
# LAYER 2: The Forecasts (Colored lines by Scenario)
geom_line(data = combined_df,
aes(x = Date, y = .mean, color = Scenario),
size = 1) +
# Optional: Add the prediction intervals (Ribbons)
# Note: .mean is the center, actual_temp is the distribution name
# usually fable outputs columns like 'lower' and 'upper' in hilo(),
# but for a simple line plot, we often skip ribbons in Apps to reduce clutter.
# Styling
scale_color_manual(values = c("Historical Data" = "black",
"Stable" = "blue",
"User Defined" = "red")) +
labs(title = "Temperature Forecast Scenarios",
subtitle = "Comparing Stable vs. User Emissions",
y = "Temperature Anomaly",
x = "Year") +
theme_minimal()
# 3. Plot Manually
ggplot() +
# LAYER 1: The Historical Data (Black line)
# We MUST specify x and y here explicitly
# LAYER 2: The Forecasts (Colored lines by Scenario)
geom_line(data = combined_df,
aes(x = Date, y = .mean, color = Scenario),
size = 1) +
# Optional: Add the prediction intervals (Ribbons)
# Note: .mean is the center, actual_temp is the distribution name
# usually fable outputs columns like 'lower' and 'upper' in hilo(),
# but for a simple line plot, we often skip ribbons in Apps to reduce clutter.
# Styling
scale_color_manual(values = c("Stable" = "blue",
"User Defined" = "white")) +
labs(title = "Temperature Forecast Scenarios",
subtitle = "Comparing Stable vs. User Emissions",
y = "Temperature Anomaly",
x = "Year") +
theme_minimal()
View(df_stable)
View(df_user)
View(stable_fc)
View(fc)
View(scenario_final)
View(temp_forecast)
View(stable_temp_forecast)
scenario_final <- scenario_stable |>
mutate(co2_ppm = fc$.mean)
scenario_final <- scenario_stable |>
mutate(co2_ppm = stable_fc$.mean)
stable_temp_forecast <- temp_model |>
forecast(new_data = scenario_final)
# 1. Convert both forecasts to plain data frames and label them
df_stable <- as_tibble(stable_temp_forecast) |> mutate(Scenario = "Stable")
df_user   <- as_tibble(temp_forecast)        |> mutate(Scenario = "User Defined")
# 2. Combine them
combined_df <- bind_rows(df_stable, df_user)
# 3. Plot Manually
ggplot() +
# LAYER 1: The Historical Data (Black line)
# We MUST specify x and y here explicitly
# LAYER 2: The Forecasts (Colored lines by Scenario)
geom_line(data = combined_df,
aes(x = Date, y = .mean, color = Scenario),
size = 1) +
# Optional: Add the prediction intervals (Ribbons)
# Note: .mean is the center, actual_temp is the distribution name
# usually fable outputs columns like 'lower' and 'upper' in hilo(),
# but for a simple line plot, we often skip ribbons in Apps to reduce clutter.
# Styling
scale_color_manual(values = c("Stable" = "blue",
"User Defined" = "red")) +
labs(title = "Temperature Forecast Scenarios",
subtitle = "Comparing Stable vs. User Emissions",
y = "Temperature Anomaly",
x = "Year") +
theme_minimal()
temp_model |> report()
ppm_model |> report()
ppm_model |>
tidy()
temp_model |>
tidy()
true_data
emissions <- read_rds("data/interpolated_co2_emissions.rds")
ppm <- read_rds("data/interpolated_co2_ppm.rds")
global_anomalolies <- read_rds("data/anomaly_ts.rds")
emissions
ppm
global_anomalolies
time <- emissions |>
left_join(ppm, by = "Date") |>
left_join(global_anomalolies, by = "Date")
write_rds(time, "data/time_series_visual.rds")
time_series |>
as_tibble() |>
group_by(year(Date)) |>
summarize(sum = sum(total_co2)) |>
mutate(Date = make_date(`year(Date)`)) |>
rename(`CO2 Emissions` = sum) |>
select(Date, `CO2 Emissions`) |>
filter(year(Date) < 2025) |>
as_tsibble() |>
autoplot() +
labs(title = "CO2 Emissions in Gigagrams", x = "Date", subtitle = "Annual Total 1850-2024") +
theme_minimal()
time |>
as_tibble() |>
group_by(year(Date)) |>
summarize(sum = sum(total_co2)) |>
mutate(Date = make_date(`year(Date)`)) |>
rename(`CO2 Emissions` = sum) |>
select(Date, `CO2 Emissions`) |>
filter(year(Date) < 2025) |>
as_tsibble() |>
autoplot() +
labs(title = "CO2 Emissions in Gigagrams", x = "Date", subtitle = "Annual Total 1850-2024") +
theme_minimal()
modeling_data <- read_rds("data/lagged_nino_predictors.rds")
modeling_data
# 3. Plot Manually
ggplot() +
# The Forecasts (Colored lines by Scenario)
geom_line(data = combined_df,
aes(x = Date, y = .mean, color = Scenario),
size = 1) +
# Optional: Add the prediction intervals (Ribbons)
# Note: .mean is the center, actual_temp is the distribution name
# usually fable outputs columns like 'lower' and 'upper' in hilo(),
# but for a simple line plot, we often skip ribbons in Apps to reduce clutter.
# Styling
scale_color_manual(values = c("Stable" = "blue",
"User Defined" = "red")) +
labs(title = "Temperature Forecast Scenarios",
subtitle = "Comparing Stable vs. User Emissions",
y = "Temperature Anomaly",
x = "Year") +
theme_minimal()
shiny::runApp('shiny_app')
runApp('shiny_app')
runApp('shiny_app')
